<?php
namespace SmartLogs;

class Logger {
  function __construct () {
    $this->payload = [];
    $this->symbols = [
      'added' => '+',
      'changed' => '*',
      'removed' => '-',
      'space' => '_'
    ];
  }


  private function checkComponents ($json) {

    # Logs MUST ALWAYS have a content and an author.
    # Removing either one of those fields might cause inaccuray during audit review
    if(!$json->data) throw new \Exception ('No specified data');
    if(!$json->author) throw new \Exception ('No specified author');
  }

  private function parse ($json) {
        
    # convert data to array
    $jsonArray = json_decode($json);

    # check if author and data is present
    self::checkComponents ($jsonArray);

    return $jsonArray;
  }


  private function compare($root = [], $new, $old) {

    # generate a two different sets to identify which has been added, updated, and removed
    # then compare both results
    $setA = self::intersect ($root = [], $new, $old, $this->symbols['added']);
    $setB = self::intersect ($root = [], $old, $new, $this->symbols['removed'], true); 
#var_dump($setB);
    # combine all items in the element
    # (old, latest)
    #$this->payload = self::array_merge_recursive_distinct($setB, $setA);
    #$this->payload = $setA;
    #$this->merged = [];
    #$this->payload = self::union($setA, $this->merged);
   # $this->p = self::union($setB, $this->payload);
#var_dump($this->p);

    return $this;
  }

  public function union ($root = [], $data) {
    
    foreach ($data as $key => $value) {
      # alter spaces to underscore _
      $keyName = str_replace(' ', '_', $key);
  
      if(gettype($root) === 'object') { 
        $root->{$keyName} = $value;
        # traverse children for non-string value
        if(gettype($value) !== 'string') $root->{$keyName} = $this->union($root->{$keyName}, $value);
      } else { 
        $root[$keyName] = $value;
        if(gettype($value) !== 'string') $root[$keyName] = $this->union($root[$keyName], $value);
        
      }
    }
    
    return $root;
  }



  private function intersect ($parent = [], $new, $old, $attr = '', $transformToNull = false) { 

    foreach ($new as $key => $value) { 

      # alter spaces to underscore _
      $keyName = str_replace(' ', '_', $key);

      # prevent missused of stdClass and array
      $oldKey = is_object($old) ? $old->{$keyName} :$old[$keyName];
      $newKey = is_object($new) ? $new->{$keyName} :$new[$keyName];

      # detect if new one exists in previous
      # if not add to stagging area
      # Note: there is no need to read all sub data since the parent does not exists
      # in the previous one and considered as relatively new
      if(!$oldKey) { #var_dump($value);
        $val = $transformToNull ? null : $value;
        $r = is_object($parent) ? ($parent->{$keyName} = $val) : ($parent[$keyName] = $val);

      } else {
        # prevent conversion of an element from stdClass to array or vised versa
        #$newParentElement = is_object($oldKey) ? new \StdClass : [];

        if(((is_int($newKey) || is_string($newKey)) && $oldKey !== $newKey)) {
          (is_object($parent)) ? ($parent->{$keyName} = $value) : ($parent[$keyName] = $value);
        }

        if(is_array($newKey) && is_array($parent)) {
          #(is_object($root)) ? ($root->{$keyName} = $value) : ($root[$keyName] = $value);
          $parent[$keyName] = $this->intersect ([], $value, $oldKey, $attr, $transformToNull) ;
        }

        if(is_object($newKey) && is_array($parent)) {   
          $parent[$keyName] = $this->intersect (new \StdClass, $value, $oldKey, $attr, $transformToNull) ; 
        }

        if(is_array($newKey) && is_object($parent)) {   
          $parent->{$keyName} = $this->intersect([], $value, $oldKey, $attr, $transformToNull) ; 
        }

        if(is_object($newKey) && is_object($parent)) {   
         # $parent->{$keyName} = $this->intersect(new \StdClass, $value, $oldKey, $attr, $transformToNull) ; 
        }

        /*if(is_object($newKey) && is_object($root)) {  
          $root->{$keyName} = $this->intersect(new \StdClass, $value, $oldKey, $attr, $transformToNull) ; 
          
        }

        if(is_object($newKey) && is_array($root)) {
          $root[$keyName] = $this->intersect (new \StdClass, $value, $oldKey, $attr, $transformToNull) ;
        }

        if(is_array($newKey) && is_array($root)) {  
          $root[$keyName] = $this->intersect ([], $value, $oldKey, $attr, $transformToNull) ;
        }

        if(is_array($newKey) && is_object($root)) { #var_dump($oldKey);
          $root->{$keyName} = $this->intersect ([], $value, $oldKey, $attr, $transformToNull) ;
        }*/
      



#var_dump($newParentElement);
        # if field is both present, consider comparing values
        # compare value only if it is a string or an integer
        # and contains different value
        /*if((in_array(gettype($oldKey), array('integer', 'string'))) && ($oldKey !== $newKey )) {
          (is_object($root)) ? ($root->{$keyName} = $value) : ($root[$keyName] = $value);
        } 

        # this is for objects or array
        if(is_object($newKey) && is_object($root)) {  
          $root->{$keyName} = $this->intersect(new \StdClass, $value, $oldKey, $attr, $transformToNull) ; 
        }

        if(is_object($newKey) && !is_object($root)) { 
          $root[$keyName] = $this->intersect($newParentElement, $value, $oldKey, $attr, $transformToNull) ;
        }

        if(is_array($newKey) && is_array($root)) { 
          $root[$keyName] = $this->intersect ([], $value, $oldKey, $attr, $transformToNull) ;
        }

        if(is_object($oldKey) && is_array($root)) {
          $root[$keyName] = $this->intersect ([], $value, $oldKey, $attr, $transformToNull) ;
        }*/
      }
    }
    return $parent;
  }

  public function diff ($json, $prevJSON = null, $sign = '') {
    # validate data
    $this->sign = $sign;
    $new = self::parse ($json);
    $prev = self::parse ($prevJSON);

    # compare result if there is a previous result
    # otherwise save the first one
    if(!$prevJSON) {
      $this->payload = $new;  
    } else {
      $this->compare([], $new->data, $prev->data);
    }
    return $this;
  }

  function merge($array1, $array2 = null, $excludeNullElements =  false) { 
   #$array = $array2;
    /*if(is_array($array1)) {
      foreach($array1 as $key => $val) { 
        if(is_string($val) || is_int($array[$key])) $array[$key] = $val;
        if(is_array($val)) {
          $array[$key] = self::merge($val, $array[$key]);
        }

        if(is_object($val)) { #var_dump($val);
          $array[$key] = self::merge($val, $array[$key]);
        }
        
        #var_dump($array[$key]);
        /*if($excludeNullElements && is_null($val)) {
          // Do not insert null elements
        } else {
          $array[$key] = is_array($val) ? self::merge((array) $val, (array) $array[$key]) : $array[$key] = $val;
        }*/
        
      /*}
    } else {
      foreach($array1 as $key => $val) { 
        if(is_array($val)) {var_dump($val);
          
          $array->{$key} = self::merge($val, $array->{$key});
          var_dump($array->{$key});
          
        } 
      }
    }
    return $array;*/

    $merged = $array1;
  
    if (is_array($array2)) {
      foreach ($array2 as $key => $val)
        if (is_array($array2[$key]))
          $merged[$key] = is_array($merged[$key]) ? self::merge($merged[$key], $array2[$key]) : $array2[$key];
        else
          if(is_object($val)) {
            var_dump($merged[$key]);
            $merged[$key] = self::merge($merged[$key], $array2[$key]);
           
          } else {
            $merged[$key] = $val;
          }
        } else {
          var_dump('no');
          #var_dump($merged);
        }     
    
    return $merged;
  }

  public function print () {
    print_r($this->payload);
  }

  public function json () {
    # returns JSON encoded result
    $this->payload = json_encode($this->payload);
    return $this;
  }


}

